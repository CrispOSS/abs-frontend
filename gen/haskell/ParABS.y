-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParABS where
import AbsABS
import LexABS
import ErrM

}

%name pProgram Program

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '!' { PT _ (TS _ 1) }
 '!=' { PT _ (TS _ 2) }
 '%' { PT _ (TS _ 3) }
 '&' { PT _ (TS _ 4) }
 '&&' { PT _ (TS _ 5) }
 '(' { PT _ (TS _ 6) }
 ')' { PT _ (TS _ 7) }
 '*' { PT _ (TS _ 8) }
 '+' { PT _ (TS _ 9) }
 ',' { PT _ (TS _ 10) }
 '-' { PT _ (TS _ 11) }
 '.' { PT _ (TS _ 12) }
 '/' { PT _ (TS _ 13) }
 ';' { PT _ (TS _ 14) }
 '<' { PT _ (TS _ 15) }
 '<=' { PT _ (TS _ 16) }
 '=' { PT _ (TS _ 17) }
 '==' { PT _ (TS _ 18) }
 '=>' { PT _ (TS _ 19) }
 '>' { PT _ (TS _ 20) }
 '>=' { PT _ (TS _ 21) }
 '?' { PT _ (TS _ 22) }
 'Fut' { PT _ (TS _ 23) }
 'Int' { PT _ (TS _ 24) }
 'Rat' { PT _ (TS _ 25) }
 'Unit' { PT _ (TS _ 26) }
 '[' { PT _ (TS _ 27) }
 ']' { PT _ (TS _ 28) }
 '_' { PT _ (TS _ 29) }
 'assert' { PT _ (TS _ 30) }
 'await' { PT _ (TS _ 31) }
 'builtin' { PT _ (TS _ 32) }
 'case' { PT _ (TS _ 33) }
 'class' { PT _ (TS _ 34) }
 'data' { PT _ (TS _ 35) }
 'def' { PT _ (TS _ 36) }
 'else' { PT _ (TS _ 37) }
 'export' { PT _ (TS _ 38) }
 'extends' { PT _ (TS _ 39) }
 'fimport' { PT _ (TS _ 40) }
 'from' { PT _ (TS _ 41) }
 'get' { PT _ (TS _ 42) }
 'if' { PT _ (TS _ 43) }
 'implements' { PT _ (TS _ 44) }
 'import' { PT _ (TS _ 45) }
 'in' { PT _ (TS _ 46) }
 'interface' { PT _ (TS _ 47) }
 'let' { PT _ (TS _ 48) }
 'local' { PT _ (TS _ 49) }
 'module' { PT _ (TS _ 50) }
 'new' { PT _ (TS _ 51) }
 'null' { PT _ (TS _ 52) }
 'return' { PT _ (TS _ 53) }
 'skip' { PT _ (TS _ 54) }
 'suspend' { PT _ (TS _ 55) }
 'then' { PT _ (TS _ 56) }
 'this' { PT _ (TS _ 57) }
 'type' { PT _ (TS _ 58) }
 'while' { PT _ (TS _ 59) }
 '{' { PT _ (TS _ 60) }
 '|' { PT _ (TS _ 61) }
 '||' { PT _ (TS _ 62) }
 '}' { PT _ (TS _ 63) }
 '~' { PT _ (TS _ 64) }

L_ident  { PT _ (TV $$) }
L_quoted { PT _ (TL $$) }
L_integ  { PT _ (TI $$) }
L_TypeIdent { PT _ (T_TypeIdent $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
String  :: { String }  : L_quoted {  $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
TypeIdent    :: { TypeIdent} : L_TypeIdent { TypeIdent ($1)}

Type :: { Type }
Type : 'Unit' { TyUnit } 
  | 'Int' { TyInt }
  | 'Rat' { TyRat }
  | 'Fut' '<' Type '>' { TyFut $3 }
  | '_' { TyUnderscore }
  | QualType { TypeVar $1 }
  | QualType '<' ListAnnType '>' { ArgType $1 $3 }


ListAnnType :: { [AnnType] }
ListAnnType : {- empty -} { [] } 
  | AnnType { (:[]) $1 }
  | AnnType ',' ListAnnType { (:) $1 $3 }


AnnType :: { AnnType }
AnnType : ListAnn Type { AnnType (reverse $1) $2 } 


QualType :: { QualType }
QualType : ListQualTypeIdent { QualType $1 } 


ListQualType :: { [QualType] }
ListQualType : {- empty -} { [] } 
  | QualType { (:[]) $1 }
  | QualType ',' ListQualType { (:) $1 $3 }


QualTypeIdent :: { QualTypeIdent }
QualTypeIdent : TypeIdent { QualTypeIdent $1 } 


ListQualTypeIdent :: { [QualTypeIdent] }
ListQualTypeIdent : {- empty -} { [] } 
  | QualTypeIdent { (:[]) $1 }
  | QualTypeIdent '.' ListQualTypeIdent { (:) $1 $3 }


Program :: { Program }
Program : ModuleDecl { Prog $1 } 


ModuleDecl :: { ModuleDecl }
ModuleDecl : 'module' QualType ';' ListExport ListImport ListAnnDecl MaybeBlock { ModuleDecl $2 (reverse $4) (reverse $5) (reverse $6) $7 } 


Export :: { Export }
Export : 'export' ListAnyIdent { ExportAny $2 } 
  | 'export' ListAnyIdent 'from' QualType { ExportAnyFrom $2 $4 }
  | 'export' '*' { ExportStar }
  | 'export' '*' 'from' QualType { ExportStarFrom $4 }


ListExport :: { [Export] }
ListExport : {- empty -} { [] } 
  | ListExport Export ';' { flip (:) $1 $2 }


ImportType :: { ImportType }
ImportType : 'fimport' { ImportHaskell } 
  | 'import' { ImportABS }


Import :: { Import }
Import : ImportType ListAnyIdent 'from' QualType { ImportAnyFrom $1 $2 $4 } 
  | ImportType '*' 'from' QualType { ImportStarFrom $1 $4 }


ListImport :: { [Import] }
ListImport : {- empty -} { [] } 
  | ListImport Import ';' { flip (:) $1 $2 }


AnyIdent :: { AnyIdent }
AnyIdent : Ident { AnyIdentI $1 } 
  | TypeIdent { AnyIdentT $1 }


ListAnyIdent :: { [AnyIdent] }
ListAnyIdent : {- empty -} { [] } 
  | AnyIdent { (:[]) $1 }
  | AnyIdent ',' ListAnyIdent { (:) $1 $3 }


AnnDecl :: { AnnDecl }
AnnDecl : ListAnn Decl { AnnDecl (reverse $1) $2 } 


Decl :: { Decl }
Decl : 'type' TypeIdent '=' Type ';' { TypeDecl $2 $4 } 
  | 'data' TypeIdent '=' ListConstrIdent ';' { DataDecl $2 $4 }
  | 'data' TypeIdent '<' ListTypeIdent '>' '=' ListConstrIdent ';' { ParDataDecl $2 $4 $7 }
  | 'def' Type Ident '(' ListParam ')' '=' FunBody ';' { Fun $2 $3 $5 $8 }
  | 'def' Type Ident '<' ListTypeIdent '>' '(' ListParam ')' '=' FunBody ';' { ParFun $2 $3 $5 $8 $11 }
  | 'interface' TypeIdent '{' ListMethSig '}' { InterfDecl $2 (reverse $4) }
  | 'interface' TypeIdent 'extends' ListQualType '{' ListMethSig '}' { ExtendsDecl $2 $4 (reverse $6) }
  | 'class' TypeIdent '{' ListBodyDecl MaybeBlock ListBodyDecl '}' { ClassDecl $2 (reverse $4) $5 (reverse $6) }
  | 'class' TypeIdent '(' ListParam ')' '{' ListBodyDecl MaybeBlock ListBodyDecl '}' { ClassParamDecl $2 $4 (reverse $7) $8 (reverse $9) }
  | 'class' TypeIdent 'implements' ListQualType '{' ListBodyDecl MaybeBlock ListBodyDecl '}' { ClassImplements $2 $4 (reverse $6) $7 (reverse $8) }
  | 'class' TypeIdent '(' ListParam ')' 'implements' ListQualType '{' ListBodyDecl MaybeBlock ListBodyDecl '}' { ClassParamImplements $2 $4 $7 (reverse $9) $10 (reverse $11) }


ConstrIdent :: { ConstrIdent }
ConstrIdent : TypeIdent { UnaryConstr $1 } 
  | TypeIdent '(' ListConstrType ')' { MultConstr $1 $3 }


ConstrType :: { ConstrType }
ConstrType : Type { EmptyConstrType $1 } 
  | Type Ident { RecordConstrType $1 $2 }


ListConstrType :: { [ConstrType] }
ListConstrType : {- empty -} { [] } 
  | ConstrType { (:[]) $1 }
  | ConstrType ',' ListConstrType { (:) $1 $3 }


ListTypeIdent :: { [TypeIdent] }
ListTypeIdent : {- empty -} { [] } 
  | TypeIdent { (:[]) $1 }
  | TypeIdent ',' ListTypeIdent { (:) $1 $3 }


ListConstrIdent :: { [ConstrIdent] }
ListConstrIdent : {- empty -} { [] } 
  | ConstrIdent { (:[]) $1 }
  | ConstrIdent '|' ListConstrIdent { (:) $1 $3 }


MethSig :: { MethSig }
MethSig : Type Ident '(' ListParam ')' { MethSig $1 $2 $4 } 


ListMethSig :: { [MethSig] }
ListMethSig : {- empty -} { [] } 
  | ListMethSig MethSig ';' { flip (:) $1 $2 }


BodyDecl :: { BodyDecl }
BodyDecl : Type Ident ';' { FieldDecl $1 $2 } 
  | Type Ident '=' PureExp ';' { FieldDeclAss $1 $2 $4 }
  | Type Ident '(' ListParam ')' Block { MethDecl $1 $2 $4 $6 }


ListBodyDecl :: { [BodyDecl] }
ListBodyDecl : {- empty -} { [] } 
  | ListBodyDecl BodyDecl { flip (:) $1 $2 }


Block :: { Block }
Block : '{' ListStm '}' { Block (reverse $2) } 


MaybeBlock :: { MaybeBlock }
MaybeBlock : Block { JustBlock $1 } 
  | {- empty -} { NoBlock }


FunBody :: { FunBody }
FunBody : 'builtin' { Builtin } 
  | PureExp { PureBody $1 }


ListAnnDecl :: { [AnnDecl] }
ListAnnDecl : {- empty -} { [] } 
  | ListAnnDecl AnnDecl { flip (:) $1 $2 }


ListStm :: { [Stm] }
ListStm : {- empty -} { [] } 
  | ListStm Stm { flip (:) $1 $2 }


Param :: { Param }
Param : AnnType Ident { Par $1 $2 } 


ListParam :: { [Param] }
ListParam : {- empty -} { [] } 
  | Param { (:[]) $1 }
  | Param ',' ListParam { (:) $1 $3 }


PureExp :: { PureExp }
PureExp : 'let' '(' Param ')' '=' PureExp 'in' PureExp { Let $3 $6 $8 } 
  | 'if' PureExp 'then' PureExp 'else' PureExp { If $2 $4 $6 }
  | 'case' PureExp '{' ListCaseBranch '}' { Case $2 (reverse $4) }
  | PureExp1 { $1 }


CaseBranch :: { CaseBranch }
CaseBranch : Pattern '=>' PureExp { CBranch $1 $3 } 


ListCaseBranch :: { [CaseBranch] }
ListCaseBranch : {- empty -} { [] } 
  | ListCaseBranch CaseBranch ';' { flip (:) $1 $2 }


Pattern :: { Pattern }
Pattern : Ident { PIdent $1 } 
  | Literal { PLit $1 }
  | TypeIdent { PUnaryConstr $1 }
  | TypeIdent '(' ListPattern ')' { PMultConstr $1 $3 }
  | '_' { PUnderscore }


ListPattern :: { [Pattern] }
ListPattern : {- empty -} { [] } 
  | Pattern { (:[]) $1 }
  | Pattern ',' ListPattern { (:) $1 $3 }


Stm :: { Stm }
Stm : EffExp ';' { SExp $1 } 
  | '{' ListStm '}' { SBlock (reverse $2) }
  | 'while' '(' PureExp ')' Stm { SWhile $3 $5 }
  | 'return' Exp ';' { SReturn $2 }
  | Ident '=' Exp ';' { SAss $1 $3 }
  | 'this' '.' Ident '=' Exp ';' { SFieldAss $3 $5 }
  | Type Ident ';' { SDec $1 $2 }
  | Type Ident '=' Exp ';' { SDecAss $1 $2 $4 }
  | 'if' '(' PureExp ')' Stm { SIf $3 $5 }
  | 'if' '(' PureExp ')' Stm 'else' Stm { SIfElse $3 $5 $7 }
  | 'await' Guard ';' { SAwait $2 }
  | 'suspend' ';' { SSuspend }
  | 'skip' ';' { SSkip }
  | 'assert' PureExp ';' { SAssert $2 }


Guard :: { Guard }
Guard : Ident '?' { VarGuard $1 } 
  | 'this' '.' Ident '?' { FieldGuard $3 }
  | PureExp { ExpGuard $1 }
  | Guard '&' Guard { AndGuard $1 $3 }


PureExp1 :: { PureExp }
PureExp1 : PureExp1 '||' PureExp2 { EOr $1 $3 } 
  | PureExp2 { $1 }


PureExp2 :: { PureExp }
PureExp2 : PureExp2 '&&' PureExp3 { EAnd $1 $3 } 
  | PureExp3 { $1 }


PureExp3 :: { PureExp }
PureExp3 : PureExp3 '==' PureExp4 { EEq $1 $3 } 
  | PureExp3 '!=' PureExp4 { ENeq $1 $3 }
  | PureExp4 { $1 }


PureExp4 :: { PureExp }
PureExp4 : PureExp4 '<' PureExp5 { ELt $1 $3 } 
  | PureExp4 '<=' PureExp5 { ELe $1 $3 }
  | PureExp4 '>' PureExp5 { EGt $1 $3 }
  | PureExp4 '>=' PureExp5 { EGe $1 $3 }
  | PureExp5 { $1 }


PureExp5 :: { PureExp }
PureExp5 : PureExp5 '+' PureExp6 { EAdd $1 $3 } 
  | PureExp5 '-' PureExp6 { ESub $1 $3 }
  | PureExp6 { $1 }


PureExp6 :: { PureExp }
PureExp6 : PureExp6 '*' PureExp7 { EMul $1 $3 } 
  | PureExp6 '/' PureExp7 { EDiv $1 $3 }
  | PureExp6 '%' PureExp7 { EMod $1 $3 }
  | PureExp7 { $1 }


PureExp7 :: { PureExp }
PureExp7 : '~' PureExp6 { ELogNeg $2 } 
  | '-' PureExp6 { EIntNeg $2 }
  | PureExp8 { $1 }


PureExp8 :: { PureExp }
PureExp8 : Ident '(' ListPureExp ')' { ECall $1 $3 } 
  | Ident '[' ListPureExp ']' { ENaryCall $1 $3 }
  | Literal { ELit $1 }
  | Ident { EVar $1 }
  | 'this' '.' Ident { EThis $3 }
  | QualType { EUnaryConstr $1 }
  | QualType '(' ListPureExp ')' { EMultConstr $1 $3 }
  | PureExp9 { $1 }


Literal :: { Literal }
Literal : 'null' { LNull } 
  | 'this' { LThis }
  | String { LStr $1 }
  | Integer { LInt $1 }


PureExp9 :: { PureExp }
PureExp9 : '(' PureExp ')' { $2 } 
  | '(' PureExp ')' { $2 }


EffExp :: { EffExp }
EffExp : 'new' Type '(' ListPureExp ')' { New $2 $4 } 
  | 'new' 'local' Type '(' ListPureExp ')' { NewLocal $3 $5 }
  | PureExp '.' Ident '(' ListPureExp ')' { SyncCall $1 $3 $5 }
  | 'this' '.' Ident '(' ListPureExp ')' { ThisSyncCall $3 $5 }
  | PureExp '!' Ident '(' ListPureExp ')' { AsyncCall $1 $3 $5 }
  | 'this' '!' Ident '(' ListPureExp ')' { ThisAsyncCall $3 $5 }
  | PureExp '.' 'get' { Get $1 }


ListPureExp :: { [PureExp] }
ListPureExp : {- empty -} { [] } 
  | PureExp { (:[]) $1 }
  | PureExp ',' ListPureExp { (:) $1 $3 }


Exp :: { Exp }
Exp : PureExp { ExpP $1 } 
  | EffExp { ExpE $1 }


Ann :: { Ann }
Ann : '[' PureExp ']' { SimpleAnn $2 } 


ListAnn :: { [Ann] }
ListAnn : {- empty -} { [] } 
  | ListAnn Ann { flip (:) $1 $2 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

